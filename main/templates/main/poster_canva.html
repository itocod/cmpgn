{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultra HD Image & GIF Creator</title>
    <style>
        :root {
            --primary: #6c5ce7;
            --secondary: #a29bfe;
            --light: #f8f9fa;
            --dark: #343a40;
            --success: #00b894;
            --premium: #fdcb6e;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #000000;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .gif-creator {
            background-color: #222222;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 450px;
            padding: 25px;
            transition: all 0.3s ease;
            color: #ffffff;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        .header h1 {
            color: var(--primary);
            font-size: 26px;
            margin-bottom: 5px;
        }

        .header p {
            color: #cccccc;
            font-size: 14px;
            opacity: 0.7;
        }

        .premium-badge {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: var(--premium);
            color: #000;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: bold;
            transform: rotate(15deg);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .upload-area {
            border: 2px dashed var(--secondary);
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            background-color: rgba(162, 155, 254, 0.05);
        }

        .upload-area:hover {
            background-color = 'rgba(162, 155, 254, 0.1)';
            border-color = 'var(--primary)';
        }

        .upload-area i {
            font-size: 40px;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .upload-area p {
            color: #cccccc;
            font-size: 14px;
        }

        .upload-area input {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            opacity: 0;
            cursor: pointer;
        }

        .controls {
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #cccccc;
            font-size: 14px;
            font-weight: 500;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: #444444;
            border-radius: 5px;
            outline: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .control-group select {
            width: 100%;
            padding: 10px;
            border-radius: 5px;
            background-color: #333333;
            color: white;
            border: 1px solid #555555;
            font-size: 14px;
        }

        .preview-container {
            position: relative;
            margin-bottom: 20px;
            display: none;
            text-align: center;
        }

        .canvas-container {
            width: 100%;
            height: 250px;
            border-radius: 10px;
            border: 1px solid #444444;
            overflow: hidden;
            background: #111111;
            margin: 0 auto;
            position: relative;
        }

        #gifCanvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            margin: 0 auto;
            object-fit: contain;
        }

        .frames-container {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            padding: 10px 0;
            margin-bottom: 20px;
            min-height: 80px;
        }

        .frame {
            width: 70px;
            height: 70px;
            border-radius: 5px;
            border: 2px solid #444444;
            object-fit: cover;
            flex-shrink: 0;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #333333;
        }

        .frame:hover {
            transform: scale(1.05);
            border-color: var(--primary);
        }

        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .btn:hover {
            background-color: #5649d1;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .btn i {
            font-size: 16px;
        }

        .btn-secondary {
            background-color: #333333;
            color: #ffffff;
            margin-top: 10px;
        }

        .btn-secondary:hover {
            background-color: #444444;
        }

        .btn-premium {
            background-color: var(--premium);
            color: #000;
            margin-top: 10px;
        }

        .btn-premium:hover {
            background-color: #f8c653;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 10px 0;
            color: #cccccc;
        }

        .spinner {
            width: 24px;
            height: 24px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            display: inline-block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .download-link {
            display: none;
            text-align: center;
            margin-top: 15px;
        }

        .download-link a {
            color: var(--success);
            text-decoration: none;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .download-link a:hover {
            text-decoration: underline;
        }

        .download-options {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .download-options a {
            flex: 1;
            padding: 8px;
            border-radius: 5px;
            background-color: #333;
            color: white;
            text-align: center;
            font-size: 12px;
            transition: all 0.2s;
        }

        .download-options a:hover {
            background-color: var(--primary);
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #555;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -100px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .quality-info {
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }

        /* Image Editor Styles */
        .editor-section {
            margin-top: 20px;
            border-top: 1px solid #444;
            padding-top: 20px;
            display: none;
        }

        .editor-section h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .editor-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .editor-btn {
            background-color: #333;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.2s;
        }

        .editor-btn:hover {
            background-color: var(--primary);
        }

        .editor-btn i {
            font-size: 14px;
        }

        .filter-controls {
            display: none;
            margin-top: 15px;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .filter-slider {
            margin-bottom: 10px;
        }

        .filter-slider label {
            display: flex;
            justify-content: space-between;
            color: #ccc;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .filter-slider input {
            width: 100%;
        }

        .filter-presets {
            display: flex;
            gap: 8px;
            overflow-x: auto;
            padding: 5px 0;
            margin-top: 10px;
        }

        .filter-preset {
            width: 60px;
            height: 60px;
            border-radius: 5px;
            border: 2px solid #444;
            cursor: pointer;
            flex-shrink: 0;
            transition: all 0.2s;
            background-size: cover;
            background-position: center;
        }

        .filter-preset:hover {
            transform: scale(1.05);
            border-color: var(--primary);
        }

        .filter-active {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(108, 92, 231, 0.3);
        }

        .crop-controls {
            display: none;
            margin-top: 15px;
        }

        .crop-aspect-ratios {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .crop-aspect-btn {
            padding: 5px 10px;
            background: #333;
            border: none;
            color: white;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .crop-aspect-btn.active {
            background: var(--primary);
        }

        .rotate-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .rotate-btn {
            flex: 1;
            padding: 8px;
            background: #333;
            border: none;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .rotate-btn i {
            font-size: 14px;
        }

        .rotate-btn:hover {
            background: var(--primary);
        }

        /* Text Editor Styles */
        .text-controls {
            display: none;
            margin-top: 15px;
        }

        .text-input-group {
            margin-bottom: 10px;
        }

        .text-input-group label {
            display: block;
            margin-bottom: 5px;
            color: #ccc;
            font-size: 12px;
        }

        .text-input-group input[type="text"],
        .text-input-group input[type="color"],
        .text-input-group select {
            width: 100%;
            padding: 8px;
            border-radius: 5px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .text-input-group input[type="range"] {
            width: 100%;
            margin-bottom: 8px;
        }

        .text-preview {
            margin-top: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 5px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .text-preview span {
            max-width: 100%;
            word-break: break-word;
            text-align: center;
        }

        .text-position-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .text-position-btn {
            background: #444;
            border: none;
            color: white;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .text-position-btn.active {
            background: var(--primary);
        }

        .text-position-btn i {
            font-size: 12px;
        }

        .text-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .text-buttons button {
            flex: 1;
        }





        /* GIF Video Loop Link Styling */
.gif-video-loop-link {
    margin-top: 20px;
    text-align: center;
}

.gif-loop-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background-color: var(--primary);
    color: white;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.gif-loop-btn:hover {
    background-color: #5649d1;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}

.gif-loop-btn i {
    font-size: 16px;
}


/* Add this to your existing CSS */
@media (max-width: 768px) {
    body {
        padding: 0;
        display: block; /* Change from flex to block for full height */
    }

    .gif-creator {
        max-width: 100%;
        border-radius: 0;
        min-height: 100vh; /* Full viewport height */
        padding: 15px;
    }

    .upload-area {
        padding: 20px 15px;
    }

    /* Make buttons slightly smaller on mobile */
    .btn {
        padding: 10px 15px;
        font-size: 13px;
    }

    /* Adjust header for mobile */
    .header h1 {
        font-size: 22px;
    }

    /* Ensure frames container doesn't cause horizontal scroll */
    .frames-container {
        padding-left: 5px;
        padding-right: 5px;
    }

    /* Make editor controls more compact */
    .editor-controls {
        grid-template-columns: 1fr;
    }
}

/* For very small devices (optional) */
@media (max-width: 480px) {
    .gif-creator {
        padding: 10px;
    }

    .upload-area {
        padding: 15px 10px;
    }

    .frame {
        width: 60px;
        height: 60px;
    }
}
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
</head>
<body>
    <div class="gif-creator">
        <div class="header">
            <span class="premium-badge">PRO</span>
            <h1>Ultra HD Image & GIF Creator</h1>
            <p>Create professional quality images and GIFs</p>
        </div>

        <div class="upload-area" id="uploadArea">
            <i class="fas fa-cloud-upload-alt"></i>
            <p>Click to upload images or drag & drop</p>
            <p><small>Supports JPG, PNG, GIF, WEBP (Max 20MB)</small></p>
            <input type="file" id="fileInput" accept="image/*" multiple>
        </div>

        <div class="preview-container" id="previewContainer">
            <div class="canvas-container">
                <canvas id="gifCanvas"></canvas>
            </div>
        </div>

        <div class="frames-container" id="framesContainer"></div>

        <!-- Image Editor Section -->
        <div class="editor-section" id="editorSection">
            <h3>
                <span><i class="fas fa-sliders-h"></i> Image Editor</span>
                <button class="editor-btn" id="toggleEditorBtn">
                    <i class="fas fa-chevron-up"></i>
                </button>
            </h3>
            
            <div class="editor-controls">
                <button class="editor-btn" id="adjustBtn">
                    <i class="fas fa-sliders-h"></i> Adjust
                </button>
                <button class="editor-btn" id="filtersBtn">
                    <i class="fas fa-paint-brush"></i> Filters
                </button>
                <button class="editor-btn" id="cropBtn">
                    <i class="fas fa-crop"></i> Crop
                </button>
                <button class="editor-btn" id="rotateBtn">
                    <i class="fas fa-sync-alt"></i> Rotate
                </button>
                <button class="editor-btn" id="textBtn">
                    <i class="fas fa-font"></i> Text
                </button>
                <button class="editor-btn" id="watermarkBtn">
                    <i class="fas fa-tag"></i> Watermark
                </button>
            </div>

            <!-- Adjust Controls -->
            <div class="filter-controls" id="adjustControls">
                <div class="filter-slider">
                    <label>
                        <span>Brightness</span>
                        <span id="brightnessValue">0</span>
                    </label>
                    <input type="range" id="brightnessControl" min="-100" max="100" value="0">
                </div>
                <div class="filter-slider">
                    <label>
                        <span>Contrast</span>
                        <span id="contrastValue">0</span>
                    </label>
                    <input type="range" id="contrastControl" min="-100" max="100" value="0">
                </div>
                <div class="filter-slider">
                    <label>
                        <span>Saturation</span>
                        <span id="saturationValue">0</span>
                    </label>
                    <input type="range" id="saturationControl" min="-100" max="100" value="0">
                </div>
                <div class="filter-slider">
                    <label>
                        <span>Temperature</span>
                        <span id="temperatureValue">0</span>
                    </label>
                    <input type="range" id="temperatureControl" min="-100" max="100" value="0">
                </div>
                <button class="btn btn-secondary" id="resetAdjustBtn" style="margin-top: 10px;">
                    <i class="fas fa-undo"></i> Reset Adjustments
                </button>
            </div>

            <!-- Filter Controls -->
            <div class="filter-controls" id="filterControls">
                <div class="filter-presets">
                    <div class="filter-preset" data-filter="none" style="background-image: url('{% static 'main/images/filter-none.jpg' %}')"></div>
                    <div class="filter-preset" data-filter="clarendon" style="background-image: url('{% static 'main/images/filter-clarendon.jpg' %}')"></div>
                    <div class="filter-preset" data-filter="gingham" style="background-image: url('{% static 'main/images/filter-gingham.jpg' %}')"></div>
                    <div class="filter-preset" data-filter="moon" style="background-image: url('{% static 'main/images/filter-moon.jpg' %}')"></div>
                    <div class="filter-preset" data-filter="lark" style="background-image: url('{% static 'main/images/filter-lark.jpg' %}')"></div>
                    <div class="filter-preset" data-filter="reyes" style="background-image: url('{% static 'main/images/filter-reyes.jpg' %}')"></div>
                    <div class="filter-preset" data-filter="juno" style="background-image: url('{% static 'main/images/filter-juno.jpg' %}')"></div>
                </div>
                <button class="btn btn-secondary" id="resetFilterBtn" style="margin-top: 10px;">
                    <i class="fas fa-undo"></i> Remove Filter
                </button>
            </div>

            <!-- Crop Controls -->
            <div class="filter-controls" id="cropControls">
                <div class="crop-aspect-ratios">
                    <button class="crop-aspect-btn" data-ratio="free">Free</button>
                    <button class="crop-aspect-btn" data-ratio="1:1">1:1</button>
                    <button class="crop-aspect-btn" data-ratio="4:3">4:3</button>
                    <button class="crop-aspect-btn" data-ratio="16:9">16:9</button>
                    <button class="crop-aspect-btn" data-ratio="original">Original</button>
                </div>
                <div class="rotate-controls">
                    <button class="rotate-btn" id="rotateLeftBtn">
                        <i class="fas fa-undo"></i> Left
                    </button>
                    <button class="rotate-btn" id="rotateRightBtn">
                        <i class="fas fa-redo"></i> Right
                    </button>
                    <button class="rotate-btn" id="flipHorizontalBtn">
                        <i class="fas fa-arrows-alt-h"></i> Flip
                    </button>
                </div>
                <button class="btn btn-secondary" id="applyCropBtn" style="margin-top: 10px;">
                    <i class="fas fa-check"></i> Apply Crop
                </button>
                <button class="btn btn-secondary" id="cancelCropBtn" style="margin-top: 10px;">
                    <i class="fas fa-times"></i> Cancel
                </button>
            </div>

            <!-- Rotate Controls -->
            <div class="filter-controls" id="rotateControls">
                <div class="rotate-controls">
                    <button class="rotate-btn" id="rotate90LeftBtn">
                        <i class="fas fa-undo"></i> 90° Left
                    </button>
                    <button class="rotate-btn" id="rotate90RightBtn">
                        <i class="fas fa-redo"></i> 90° Right
                    </button>
                </div>
                <div class="rotate-controls" style="margin-top: 10px;">
                    <button class="rotate-btn" id="rotate180Btn">
                        <i class="fas fa-sync-alt"></i> 180°
                    </button>
                    <button class="rotate-btn" id="flipVerticalBtn">
                        <i class="fas fa-arrows-alt-v"></i> Flip Vert
                    </button>
                </div>
                <button class="btn btn-secondary" id="applyRotateBtn" style="margin-top: 10px;">
                    <i class="fas fa-check"></i> Apply Rotation
                </button>
            </div>

            <!-- Text Controls -->
            <div class="filter-controls" id="textControls">
                <div class="text-input-group">
                    <label for="textInput">Text Content</label>
                    <input type="text" id="textInput" placeholder="Enter your text here">
                </div>
                
                <div class="text-input-group">
                    <label for="textFont">Font</label>
                    <select id="textFont">
                        <option value="Arial">Arial</option>
                        <option value="Verdana">Verdana</option>
                        <option value="Helvetica">Helvetica</option>
                        <option value="Times New Roman">Times New Roman</option>
                        <option value="Courier New">Courier New</option>
                        <option value="Georgia">Georgia</option>
                        <option value="Palatino">Palatino</option>
                        <option value="Garamond">Garamond</option>
                        <option value="Comic Sans MS">Comic Sans</option>
                        <option value="Impact">Impact</option>
                    </select>
                </div>
                
                <div class="text-input-group">
                    <label for="textSize">Size: <span id="textSizeValue">24</span>px</label>
                    <input type="range" id="textSize" min="8" max="72" value="24">
                </div>
                
                <div class="text-input-group">
                    <label for="textColor">Color</label>
                    <input type="color" id="textColor" value="#ffffff">
                </div>
                
                <div class="text-input-group">
                    <label for="textBgColor">Background Color</label>
                    <input type="color" id="textBgColor" value="#00000000">
                </div>
                
                <div class="text-input-group">
                    <label for="textOpacity">Opacity: <span id="textOpacityValue">100</span>%</label>
                    <input type="range" id="textOpacity" min="0" max="100" value="100">
                </div>
                
                <div class="text-preview" id="textPreview">
                    <span>Text Preview</span>
                </div>
                
                <div class="text-position-controls">
                    <button class="text-position-btn" data-position="top-left"><i class="fas fa-arrow-up-left"></i></button>
                    <button class="text-position-btn" data-position="top-center"><i class="fas fa-arrow-up"></i></button>
                    <button class="text-position-btn" data-position="top-right"><i class="fas fa-arrow-up-right"></i></button>
                    <button class="text-position-btn" data-position="middle-left"><i class="fas fa-arrow-left"></i></button>
                    <button class="text-position-btn" data-position="middle-center"><i class="fas fa-circle"></i></button>
                    <button class="text-position-btn" data-position="middle-right"><i class="fas fa-arrow-right"></i></button>
                    <button class="text-position-btn" data-position="bottom-left"><i class="fas fa-arrow-down-left"></i></button>
                    <button class="text-position-btn" data-position="bottom-center"><i class="fas fa-arrow-down"></i></button>
                    <button class="text-position-btn" data-position="bottom-right"><i class="fas fa-arrow-down-right"></i></button>
                </div>
                
                <div class="text-buttons">
                    <button class="btn btn-secondary" id="addTextBtn">
                        <i class="fas fa-plus"></i> Add Text
                    </button>
                    <button class="btn btn-secondary" id="clearTextBtn">
                        <i class="fas fa-trash"></i> Clear
                    </button>
                </div>
            </div>

            <!-- Watermark Controls -->
            <div class="filter-controls" id="watermarkControls">
                <div class="text-input-group">
                    <label for="watermarkText">Watermark Text</label>
                    <input type="text" id="watermarkText" value="@{{ username }}">
                </div>
                
                <div class="text-input-group">
                    <label for="watermarkSize">Size: <span id="watermarkSizeValue">16</span>px</label>
                    <input type="range" id="watermarkSize" min="8" max="72" value="16">
                </div>
                
                <div class="text-input-group">
                    <label for="watermarkColor">Color</label>
                    <input type="color" id="watermarkColor" value="#ffffff">
                </div>
                
                <div class="text-input-group">
                    <label for="watermarkOpacity">Opacity: <span id="watermarkOpacityValue">70</span>%</label>
                    <input type="range" id="watermarkOpacity" min="0" max="100" value="70">
                </div>
                
                <div class="text-input-group">
                    <label for="watermarkPosition">Position</label>
                    <select id="watermarkPosition">
                        <option value="bottom-right">Bottom Right</option>
                        <option value="bottom-left">Bottom Left</option>
                        <option value="top-right">Top Right</option>
                        <option value="top-left">Top Left</option>
                        <option value="center">Center</option>
                    </select>
                </div>
                
                <div class="text-buttons">
                    <button class="btn btn-secondary" id="applyWatermarkBtn">
                        <i class="fas fa-check"></i> Apply Watermark
                    </button>
                    <button class="btn btn-secondary" id="removeWatermarkBtn">
                        <i class="fas fa-trash"></i> Remove
                    </button>
                </div>
            </div>
        </div>

        <div class="controls">
            <div class="control-group">
                <label for="speedControl">Preview Speed: <span id="speedValue">500ms (Normal)</span></label>
                <input type="range" id="speedControl" min="50" max="2000" value="500" step="50">
            </div>
            <div class="control-group">
                <label for="gifSpeedControl">GIF Speed: <span id="gifSpeedValue">5000ms (Very Slow)</span></label>
                <input type="range" id="gifSpeedControl" min="100" max="20000" value="5000" step="100">
            </div>
            <div class="control-group">
                <label for="sizeControl">Output Size: <span id="sizeValue">300</span>px</label>
                <input type="range" id="sizeControl" min="100" max="2000" value="300" step="50">
                <div class="quality-info">For best quality, use 1000px or higher</div>
            </div>
            <div class="control-group">
                <label for="qualityPreset">Quality Preset:</label>
                <select id="qualityPreset">
                    <option value="low">Low (Small File)</option>
                    <option value="medium" selected>Medium (Balanced)</option>
                    <option value="high">High (Best Quality)</option>
                    <option value="ultra">Ultra HD (Professional)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="qualityControl">Quality Fine-Tune: <span id="qualityValue">10</span></label>
                <input type="range" id="qualityControl" min="1" max="20" value="10" step="1">
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="enhanceQuality" checked> Enhance Image Quality
                </label>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Creating your high-quality output...</p>
        </div>

        <button class="btn" id="createGifBtn" disabled>
            <i class="fas fa-magic"></i> Create GIF
        </button>
        <button class="btn btn-premium" id="createHdImageBtn">
            <i class="fas fa-crown"></i> Create Ultra HD Image
        </button>
        <button class="btn btn-secondary" id="resetBtn">
            <i class="fas fa-redo"></i> Reset
        </button>

        <div class="download-link" id="downloadLink">
            <a href="#" id="downloadAnchor"><i class="fas fa-download"></i> Download Output</a>
            <div class="download-options">
                <a href="#" id="downloadHd" class="tooltip">HD <span class="tooltiptext">High Quality (WebP)</span></a>
                <a href="#" id="downloadPrint" class="tooltip">Print <span class="tooltiptext">Print Quality (PNG)</span></a>
                <a href="#" id="downloadOriginal" class="tooltip">Original <span class="tooltiptext">Original Format</span></a>
            </div>
        </div>

        <div class="gif-video-loop-link">
    <a href="{% url 'video_canva' %}" class="gif-loop-btn">
        <i class="fas fa-sync-alt"></i>Create GIF Video Loops
    </a>
</div>
    </div>

    <!-- Load local GIF library -->
    <script src="{% static 'main/js/gif.js' %}"></script>
    
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // DOM Elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const previewContainer = document.getElementById('previewContainer');
        const gifCanvas = document.getElementById('gifCanvas');
        const ctx = gifCanvas.getContext('2d', { willReadFrequently: true });
        const framesContainer = document.getElementById('framesContainer');
        const speedControl = document.getElementById('speedControl');
        const speedValue = document.getElementById('speedValue');
        const gifSpeedControl = document.getElementById('gifSpeedControl');
        const gifSpeedValue = document.getElementById('gifSpeedValue');
        const sizeControl = document.getElementById('sizeControl');
        const sizeValue = document.getElementById('sizeValue');
        const createGifBtn = document.getElementById('createGifBtn');
        const createHdImageBtn = document.getElementById('createHdImageBtn');
        const resetBtn = document.getElementById('resetBtn');
        const loading = document.getElementById('loading');
        const downloadLink = document.getElementById('downloadLink');
        const downloadAnchor = document.getElementById('downloadAnchor');
        const downloadHd = document.getElementById('downloadHd');
        const downloadPrint = document.getElementById('downloadPrint');
        const downloadOriginal = document.getElementById('downloadOriginal');
        const qualityPreset = document.getElementById('qualityPreset');
        const qualityControl = document.getElementById('qualityControl');
        const qualityValue = document.getElementById('qualityValue');
        const enhanceQuality = document.getElementById('enhanceQuality');

        // Image Editor Elements
        const editorSection = document.getElementById('editorSection');
        const toggleEditorBtn = document.getElementById('toggleEditorBtn');
        const adjustBtn = document.getElementById('adjustBtn');
        const filtersBtn = document.getElementById('filtersBtn');
        const cropBtn = document.getElementById('cropBtn');
        const rotateBtn = document.getElementById('rotateBtn');
        const textBtn = document.getElementById('textBtn');
        const watermarkBtn = document.getElementById('watermarkBtn');
        const adjustControls = document.getElementById('adjustControls');
        const filterControls = document.getElementById('filterControls');
        const cropControls = document.getElementById('cropControls');
        const rotateControls = document.getElementById('rotateControls');
        const textControls = document.getElementById('textControls');
        const watermarkControls = document.getElementById('watermarkControls');
        const brightnessControl = document.getElementById('brightnessControl');
        const brightnessValue = document.getElementById('brightnessValue');
        const contrastControl = document.getElementById('contrastControl');
        const contrastValue = document.getElementById('contrastValue');
        const saturationControl = document.getElementById('saturationControl');
        const saturationValue = document.getElementById('saturationValue');
        const temperatureControl = document.getElementById('temperatureControl');
        const temperatureValue = document.getElementById('temperatureValue');
        const resetAdjustBtn = document.getElementById('resetAdjustBtn');
        const filterPresets = document.querySelectorAll('.filter-preset');
        const resetFilterBtn = document.getElementById('resetFilterBtn');
        const cropAspectBtns = document.querySelectorAll('.crop-aspect-btn');
        const rotateLeftBtn = document.getElementById('rotateLeftBtn');
        const rotateRightBtn = document.getElementById('rotateRightBtn');
        const flipHorizontalBtn = document.getElementById('flipHorizontalBtn');
        const applyCropBtn = document.getElementById('applyCropBtn');
        const cancelCropBtn = document.getElementById('cancelCropBtn');
        const rotate90LeftBtn = document.getElementById('rotate90LeftBtn');
        const rotate90RightBtn = document.getElementById('rotate90RightBtn');
        const rotate180Btn = document.getElementById('rotate180Btn');
        const flipVerticalBtn = document.getElementById('flipVerticalBtn');
        const applyRotateBtn = document.getElementById('applyRotateBtn');
        
        // Text Editor Elements
        const textInput = document.getElementById('textInput');
        const textFont = document.getElementById('textFont');
        const textSize = document.getElementById('textSize');
        const textSizeValue = document.getElementById('textSizeValue');
        const textColor = document.getElementById('textColor');
        const textBgColor = document.getElementById('textBgColor');
        const textOpacity = document.getElementById('textOpacity');
        const textOpacityValue = document.getElementById('textOpacityValue');
        const textPreview = document.getElementById('textPreview');
        const textPositionBtns = document.querySelectorAll('.text-position-btn');
        const addTextBtn = document.getElementById('addTextBtn');
        const clearTextBtn = document.getElementById('clearTextBtn');
        
        // Watermark Editor Elements
        const watermarkText = document.getElementById('watermarkText');
        const watermarkSize = document.getElementById('watermarkSize');
        const watermarkSizeValue = document.getElementById('watermarkSizeValue');
        const watermarkColor = document.getElementById('watermarkColor');
        const watermarkOpacity = document.getElementById('watermarkOpacity');
        const watermarkOpacityValue = document.getElementById('watermarkOpacityValue');
        const watermarkPosition = document.getElementById('watermarkPosition');
        const applyWatermarkBtn = document.getElementById('applyWatermarkBtn');
        const removeWatermarkBtn = document.getElementById('removeWatermarkBtn');

        // Variables
        let images = [];
        let originalImages = [];
        let animationInterval = null;
        let currentDownloadUrl = null;
        let currentOutputType = null;
        let currentFilter = 'none';
        let currentAdjustments = {
            brightness: 0,
            contrast: 0,
            saturation: 0,
            temperature: 0
        };
        let isEditorOpen = true;
        let isCropping = false;
        let currentAspectRatio = 'free';
        let currentRotation = 0;
        let isFlipped = false;
        
        // Text variables
        let textElements = [];
        let currentTextPosition = 'bottom-right';
        let watermarkSettings = {
            text: "@{{ username }}",
            size: 16,
            color: "#ffffff",
            opacity: 70,
            position: "bottom-right",
            enabled: false
        };

        // Event Listeners
        
         // Remove the click event that triggers file input
    // uploadArea.addEventListener('click', () => fileInput.click());
    
    // Keep the drag and drop events
    uploadArea.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadArea.style.backgroundColor = 'rgba(162, 155, 254, 0.2)';
        uploadArea.style.borderColor = 'var(--primary)';
    });
    uploadArea.addEventListener('dragleave', () => {
        uploadArea.style.backgroundColor = 'rgba(162, 155, 254, 0.05)';
        uploadArea.style.borderColor = 'var(--secondary)';
    });
    uploadArea.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadArea.style.backgroundColor = 'rgba(162, 155, 254, 0.05)';
        uploadArea.style.borderColor = 'var(--secondary)';
        handleFiles(e.dataTransfer.files);
    });

    // Only handle the file input change event
    fileInput.addEventListener('change', () => {
        if (fileInput.files.length > 0) {
            handleFiles(fileInput.files);
        }
    });

        fileInput.addEventListener('change', () => handleFiles(fileInput.files));
        speedControl.addEventListener('input', updateSpeedValue);
        gifSpeedControl.addEventListener('input', updateGifSpeedValue);
        sizeControl.addEventListener('input', updateSizeValue);
        createGifBtn.addEventListener('click', createGif);
        createHdImageBtn.addEventListener('click', createHdImage);
        resetBtn.addEventListener('click', resetAll);
        qualityPreset.addEventListener('change', updateQualityPreset);
        qualityControl.addEventListener('input', updateQualityValue);
        downloadHd.addEventListener('click', downloadHdVersion);
        downloadPrint.addEventListener('click', downloadPrintVersion);
        downloadOriginal.addEventListener('click', downloadOriginalVersion);

        // Image Editor Event Listeners
        toggleEditorBtn.addEventListener('click', toggleEditor);
        adjustBtn.addEventListener('click', () => showEditorControls('adjust'));
        filtersBtn.addEventListener('click', () => showEditorControls('filter'));
        cropBtn.addEventListener('click', () => showEditorControls('crop'));
        rotateBtn.addEventListener('click', () => showEditorControls('rotate'));
        textBtn.addEventListener('click', () => showEditorControls('text'));
        watermarkBtn.addEventListener('click', () => showEditorControls('watermark'));
        brightnessControl.addEventListener('input', updateBrightnessValue);
        contrastControl.addEventListener('input', updateContrastValue);
        saturationControl.addEventListener('input', updateSaturationValue);
        temperatureControl.addEventListener('input', updateTemperatureValue);
        resetAdjustBtn.addEventListener('click', resetAdjustments);
        filterPresets.forEach(preset => preset.addEventListener('click', applyFilterPreset));
        resetFilterBtn.addEventListener('click', resetFilter);
        cropAspectBtns.forEach(btn => btn.addEventListener('click', setCropAspectRatio));
        rotateLeftBtn.addEventListener('click', () => rotateImage(-90));
        rotateRightBtn.addEventListener('click', () => rotateImage(90));
        flipHorizontalBtn.addEventListener('click', () => flipImage('horizontal'));
        applyCropBtn.addEventListener('click', applyCrop);
        cancelCropBtn.addEventListener('click', cancelCrop);
        rotate90LeftBtn.addEventListener('click', () => rotateImage(-90));
        rotate90RightBtn.addEventListener('click', () => rotateImage(90));
        rotate180Btn.addEventListener('click', () => rotateImage(180));
        flipVerticalBtn.addEventListener('click', () => flipImage('vertical'));
        applyRotateBtn.addEventListener('click', applyRotation);
        
        // Text Editor Event Listeners
        textInput.addEventListener('input', updateTextPreview);
        textFont.addEventListener('change', updateTextPreview);
        textSize.addEventListener('input', updateTextSizeValue);
        textColor.addEventListener('input', updateTextPreview);
        textBgColor.addEventListener('input', updateTextPreview);
        textOpacity.addEventListener('input', updateTextOpacityValue);
        textPositionBtns.forEach(btn => btn.addEventListener('click', setTextPosition));
        addTextBtn.addEventListener('click', addTextToImage);
        clearTextBtn.addEventListener('click', clearAllText);
        
        // Watermark Editor Event Listeners
        watermarkText.addEventListener('input', updateWatermarkSettings);
        watermarkSize.addEventListener('input', updateWatermarkSizeValue);
        watermarkColor.addEventListener('input', updateWatermarkSettings);
        watermarkOpacity.addEventListener('input', updateWatermarkOpacityValue);
        watermarkPosition.addEventListener('change', updateWatermarkSettings);
        applyWatermarkBtn.addEventListener('click', applyWatermark);
        removeWatermarkBtn.addEventListener('click', removeWatermark);

        // Initial setup
        updateSpeedValue();
        updateGifSpeedValue();
        updateSizeValue();
        updateQualityValue();
        downloadLink.style.display = 'none';
        hideAllEditorControls();
        updateTextPreview();
        updateTextSizeValue();
        updateTextOpacityValue();
        updateWatermarkSizeValue();
        updateWatermarkOpacityValue();

        // Functions
        function toggleEditor() {
            isEditorOpen = !isEditorOpen;
            if (isEditorOpen) {
                editorSection.style.display = 'block';
                toggleEditorBtn.innerHTML = '<i class="fas fa-chevron-up"></i>';
            } else {
                editorSection.style.display = 'none';
                toggleEditorBtn.innerHTML = '<i class="fas fa-chevron-down"></i>';
                hideAllEditorControls();
            }
        }

        function showEditorControls(type) {
            hideAllEditorControls();
            
            switch(type) {
                case 'adjust':
                    adjustControls.style.display = 'block';
                    break;
                case 'filter':
                    filterControls.style.display = 'block';
                    break;
                case 'crop':
                    cropControls.style.display = 'block';
                    isCropping = true;
                    break;
                case 'rotate':
                    rotateControls.style.display = 'block';
                    break;
                case 'text':
                    textControls.style.display = 'block';
                    break;
                case 'watermark':
                    watermarkControls.style.display = 'block';
                    break;
            }
            
            // Redraw canvas with current settings
            if (images.length > 0) {
                const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
                if (selectedFrame) {
                    const img = new Image();
                    img.src = selectedFrame.src;
                    img.onload = () => drawImageToCanvas(img);
                }
            }
        }

        function hideAllEditorControls() {
            adjustControls.style.display = 'none';
            filterControls.style.display = 'none';
            cropControls.style.display = 'none';
            rotateControls.style.display = 'none';
            textControls.style.display = 'none';
            watermarkControls.style.display = 'none';
            isCropping = false;
        }

        function updateBrightnessValue() {
            currentAdjustments.brightness = parseInt(brightnessControl.value);
            brightnessValue.textContent = currentAdjustments.brightness;
            applyAdjustments();
        }

        function updateContrastValue() {
            currentAdjustments.contrast = parseInt(contrastControl.value);
            contrastValue.textContent = currentAdjustments.contrast;
            applyAdjustments();
        }

        function updateSaturationValue() {
            currentAdjustments.saturation = parseInt(saturationControl.value);
            saturationValue.textContent = currentAdjustments.saturation;
            applyAdjustments();
        }

        function updateTemperatureValue() {
            currentAdjustments.temperature = parseInt(temperatureControl.value);
            temperatureValue.textContent = currentAdjustments.temperature;
            applyAdjustments();
        }

        function resetAdjustments() {
            brightnessControl.value = 0;
            contrastControl.value = 0;
            saturationControl.value = 0;
            temperatureControl.value = 0;
            currentAdjustments = {
                brightness: 0,
                contrast: 0,
                saturation: 0,
                temperature: 0
            };
            brightnessValue.textContent = '0';
            contrastValue.textContent = '0';
            saturationValue.textContent = '0';
            temperatureValue.textContent = '0';
            applyAdjustments();
        }

        function applyAdjustments() {
            if (images.length === 0) return;
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            if (!selectedFrame) return;
            
            const img = new Image();
            img.src = selectedFrame.src;
            img.onload = function() {
                drawImageToCanvas(img);
            };
        }

        function applyFilterPreset(e) {
            filterPresets.forEach(p => p.classList.remove('filter-active'));
            this.classList.add('filter-active');
            currentFilter = this.dataset.filter;
            
            if (images.length === 0) return;
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            if (!selectedFrame) return;
            
            const img = new Image();
            img.src = selectedFrame.src;
            img.onload = function() {
                drawImageToCanvas(img);
            };
        }

        function resetFilter() {
            filterPresets.forEach(p => p.classList.remove('filter-active'));
            currentFilter = 'none';
            
            if (images.length === 0) return;
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            if (!selectedFrame) return;
            
            const img = new Image();
            img.src = selectedFrame.src;
            img.onload = function() {
                drawImageToCanvas(img);
            };
        }

        function setCropAspectRatio(e) {
            cropAspectBtns.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            currentAspectRatio = this.dataset.ratio;
            
            // In a real implementation, you would show crop handles on the canvas
            // For this example, we'll just log the selected aspect ratio
            console.log('Selected aspect ratio:', currentAspectRatio);
        }

        function rotateImage(degrees) {
            currentRotation += degrees;
            
            if (images.length === 0) return;
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            if (!selectedFrame) return;
            
            const img = new Image();
            img.src = selectedFrame.src;
            img.onload = function() {
                drawImageToCanvas(img);
            };
        }

        function flipImage(direction) {
            if (direction === 'horizontal') {
                isFlipped = !isFlipped;
            } else if (direction === 'vertical') {
                // Vertical flip logic would go here
            }
            
            if (images.length === 0) return;
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            if (!selectedFrame) return;
            
            const img = new Image();
            img.src = selectedFrame.src;
            img.onload = function() {
                drawImageToCanvas(img);
            };
        }

        function applyCrop() {
            // In a real implementation, this would apply the crop to the image
            console.log('Applying crop with aspect ratio:', currentAspectRatio);
            isCropping = false;
            hideAllEditorControls();
            
            if (images.length === 0) return;
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            if (!selectedFrame) return;
            
            const img = new Image();
            img.src = selectedFrame.src;
            img.onload = function() {
                drawImageToCanvas(img);
            };
        }

        function cancelCrop() {
            isCropping = false;
            hideAllEditorControls();
            
            if (images.length === 0) return;
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            if (!selectedFrame) return;
            
            const img = new Image();
            img.src = selectedFrame.src;
            img.onload = function() {
                drawImageToCanvas(img);
            };
        }

        function applyRotation() {
            // In a real implementation, this would permanently apply the rotation
            hideAllEditorControls();
            
            if (images.length === 0) return;
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            if (!selectedFrame) return;
            
            const img = new Image();
            img.src = selectedFrame.src;
            img.onload = function() {
                drawImageToCanvas(img);
            };
        }

        function applyImageEffects(image, size) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = size;
            tempCanvas.height = size;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Apply rotation and flip
            tempCtx.save();
            tempCtx.translate(size / 2, size / 2);
            tempCtx.rotate(currentRotation * Math.PI / 180);
            if (isFlipped) {
                tempCtx.scale(-1, 1);
            }
            
            const ratio = Math.min(size / image.width, size / image.height);
            const width = image.width * ratio;
            const height = image.height * ratio;
            const x = -width / 2;
            const y = -height / 2;
            
            // Always use black background
            tempCtx.fillStyle = '#000000';
            tempCtx.fillRect(-size / 2, -size / 2, size, size);
            
            tempCtx.drawImage(image, x, y, width, height);
            tempCtx.restore();
            
            // Apply filters and adjustments
            if (currentFilter !== 'none' || 
                currentAdjustments.brightness !== 0 || 
                currentAdjustments.contrast !== 0 || 
                currentAdjustments.saturation !== 0 || 
                currentAdjustments.temperature !== 0) {
                
                const imageData = tempCtx.getImageData(0, 0, size, size);
                const data = imageData.data;
                
                // Apply brightness
                if (currentAdjustments.brightness !== 0) {
                    const brightness = currentAdjustments.brightness / 100;
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] += 255 * brightness;
                        data[i + 1] += 255 * brightness;
                        data[i + 2] += 255 * brightness;
                    }
                }
                
                // Apply contrast
                if (currentAdjustments.contrast !== 0) {
                    const contrast = (currentAdjustments.contrast + 100) / 100;
                    const intercept = 128 * (1 - contrast);
                    for (let i = 0; i < data.length; i += 4) {
                        data[i] = data[i] * contrast + intercept;
                        data[i + 1] = data[i + 1] * contrast + intercept;
                        data[i + 2] = data[i + 2] * contrast + intercept;
                    }
                }
                
                // Apply saturation
                if (currentAdjustments.saturation !== 0) {
                    const saturation = (currentAdjustments.saturation + 100) / 100;
                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
                        data[i] = gray + saturation * (r - gray);
                        data[i + 1] = gray + saturation * (g - gray);
                        data[i + 2] = gray + saturation * (b - gray);
                    }
                }
                
                // Apply temperature (warm/cool)
                if (currentAdjustments.temperature !== 0) {
                    const temp = currentAdjustments.temperature / 100;
                    for (let i = 0; i < data.length; i += 4) {
                        if (temp > 0) {
                            // Warm (increase red, decrease blue)
                            data[i] += 255 * temp;
                            data[i + 2] -= 255 * temp;
                        } else {
                            // Cool (increase blue, decrease red)
                            data[i] += 255 * temp;
                            data[i + 2] -= 255 * temp;
                        }
                    }
                }
                
                // Apply Instagram-like filters
                if (currentFilter !== 'none') {
                    switch(currentFilter) {
                        case 'clarendon':
                            // Increase contrast and saturation slightly
                            for (let i = 0; i < data.length; i += 4) {
                                data[i] = Math.min(255, data[i] * 1.1);
                                data[i + 1] = Math.min(255, data[i + 1] * 1.05);
                                data[i + 2] = Math.max(0, data[i + 2] * 0.95);
                            }
                            break;
                        case 'gingham':
                            // Vintage washed out look
                            for (let i = 0; i < data.length; i += 4) {
                                data[i] = Math.min(255, data[i] * 0.9 + 50);
                                data[i + 1] = Math.min(255, data[i + 1] * 0.9 + 50);
                                data[i + 2] = Math.min(255, data[i + 2] * 0.9 + 50);
                            }
                            break;
                        case 'moon':
                            // Black and white
                            for (let i = 0; i < data.length; i += 4) {
                                const avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                                data[i] = avg;
                                data[i + 1] = avg;
                                data[i + 2] = avg;
                            }
                            break;
                        case 'lark':
                            // Bright and airy
                            for (let i = 0; i < data.length; i += 4) {
                                data[i] = Math.min(255, data[i] * 1.2);
                                data[i + 1] = Math.min(255, data[i + 1] * 1.1);
                                data[i + 2] = Math.min(255, data[i + 2] * 0.9);
                            }
                            break;
                        case 'reyes':
                            // Warm vintage
                            for (let i = 0; i < data.length; i += 4) {
                                data[i] = Math.min(255, data[i] * 1.2);
                                data[i + 1] = Math.min(255, data[i + 1] * 1.1);
                                data[i + 2] = Math.max(0, data[i + 2] * 0.8);
                            }
                            break;
                        case 'juno':
                            // Cool tones with magenta tint
                            for (let i = 0; i < data.length; i += 4) {
                                data[i] = Math.min(255, data[i] * 1.1);
                                data[i + 1] = Math.max(0, data[i + 1] * 0.9);
                                data[i + 2] = Math.min(255, data[i + 2] * 1.05);
                            }
                            break;
                    }
                }
                
                tempCtx.putImageData(imageData, 0, 0);
            }
            
            return tempCanvas;
        }

        function updateQualityPreset() {
            const preset = qualityPreset.value;
            switch(preset) {
                case 'low':
                    qualityControl.value = 5;
                    break;
                case 'medium':
                    qualityControl.value = 10;
                    break;
                case 'high':
                    qualityControl.value = 15;
                    break;
                case 'ultra':
                    qualityControl.value = 20;
                    break;
            }
            updateQualityValue();
        }

        function updateQualityValue() {
            qualityValue.textContent = qualityControl.value;
        }

        function enhanceImage(image, size, isForPrint = false) {
            const tempCanvas = document.createElement('canvas');
            const targetSize = isForPrint ? size * 2 : size;
            tempCanvas.width = targetSize;
            tempCanvas.height = targetSize;
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCtx.imageSmoothingEnabled = true;
            tempCtx.imageSmoothingQuality = 'high';
            
            // Apply all image effects (rotations, filters, adjustments)
            const processedCanvas = applyImageEffects(image, targetSize);
            tempCtx.drawImage(processedCanvas, 0, 0);
            
            // Add text elements
            if (textElements.length > 0) {
                textElements.forEach(text => {
                    drawTextElement(tempCtx, text, targetSize);
                });
            }
            
            // Add watermark if enabled
            if (watermarkSettings.enabled) {
                drawWatermark(tempCtx, targetSize);
            }
            
            if (enhanceQuality.checked) {
                tempCtx.filter = 'contrast(1.1) saturate(1.1) brightness(1.02)';
                tempCtx.drawImage(tempCanvas, 0, 0);
                tempCtx.filter = 'none';
                
                if (isForPrint) {
                    sharpenImage(tempCanvas, 0.5);
                }
            }
            
            return tempCanvas;
        }

        function drawTextElement(ctx, text, canvasSize) {
            ctx.save();
            
            // Set font properties
            const fontSize = text.size * (canvasSize / 500); // Scale font size based on canvas size
            ctx.font = `${text.fontWeight} ${fontSize}px ${text.fontFamily}`;
            
            // Calculate text position
            const textMetrics = ctx.measureText(text.content);
            const textWidth = textMetrics.width;
            const textHeight = fontSize;
            
            let x, y;
            const padding = 10 * (canvasSize / 500); // Scale padding
            
            switch(text.position) {
                case 'top-left':
                    x = padding;
                    y = padding + textHeight;
                    break;
                case 'top-center':
                    x = canvasSize / 2 - textWidth / 2;
                    y = padding + textHeight;
                    break;
                case 'top-right':
                    x = canvasSize - textWidth - padding;
                    y = padding + textHeight;
                    break;
                case 'middle-left':
                    x = padding;
                    y = canvasSize / 2 + textHeight / 2;
                    break;
                case 'middle-center':
                    x = canvasSize / 2 - textWidth / 2;
                    y = canvasSize / 2 + textHeight / 2;
                    break;
                case 'middle-right':
                    x = canvasSize - textWidth - padding;
                    y = canvasSize / 2 + textHeight / 2;
                    break;
                case 'bottom-left':
                    x = padding;
                    y = canvasSize - padding;
                    break;
                case 'bottom-center':
                    x = canvasSize / 2 - textWidth / 2;
                    y = canvasSize - padding;
                    break;
                case 'bottom-right':
                    x = canvasSize - textWidth - padding;
                    y = canvasSize - padding;
                    break;
                default:
                    x = canvasSize - textWidth - padding;
                    y = canvasSize - padding;
            }
            
            // Draw background if not fully transparent
            if (text.bgColor !== '#00000000') {
                const bgPadding = 5 * (canvasSize / 500);
                const bgWidth = textWidth + bgPadding * 2;
                const bgHeight = textHeight + bgPadding * 2;
                
                ctx.fillStyle = text.bgColor;
                ctx.globalAlpha = text.opacity / 100;
                ctx.fillRect(
                    x - bgPadding, 
                    y - textHeight - bgPadding, 
                    bgWidth, 
                    bgHeight
                );
            }
            
            // Draw text
            ctx.fillStyle = text.color;
            ctx.globalAlpha = text.opacity / 100;
            ctx.textBaseline = 'bottom';
            ctx.fillText(text.content, x, y);
            
            ctx.restore();
        }

        function drawWatermark(ctx, canvasSize) {
            ctx.save();
            
            // Set font properties
            const fontSize = watermarkSettings.size * (canvasSize / 500); // Scale font size based on canvas size
            ctx.font = `bold ${fontSize}px Arial`;
            ctx.fillStyle = watermarkSettings.color;
            ctx.globalAlpha = watermarkSettings.opacity / 100;
            
            // Calculate text position
            const textMetrics = ctx.measureText(watermarkSettings.text);
            const textWidth = textMetrics.width;
            const textHeight = fontSize;
            
            let x, y;
            const padding = 10 * (canvasSize / 500); // Scale padding
            
            switch(watermarkSettings.position) {
                case 'top-left':
                    x = padding;
                    y = padding + textHeight;
                    break;
                case 'top-right':
                    x = canvasSize - textWidth - padding;
                    y = padding + textHeight;
                    break;
                case 'bottom-left':
                    x = padding;
                    y = canvasSize - padding;
                    break;
                case 'bottom-right':
                    x = canvasSize - textWidth - padding;
                    y = canvasSize - padding;
                    break;
                case 'center':
                    x = canvasSize / 2 - textWidth / 2;
                    y = canvasSize / 2 + textHeight / 2;
                    break;
                default:
                    x = canvasSize - textWidth - padding;
                    y = canvasSize - padding;
            }
            
            // Draw text with stroke for better visibility
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 1 * (canvasSize / 500);
            ctx.strokeText(watermarkSettings.text, x, y);
            ctx.fillText(watermarkSettings.text, x, y);
            
            ctx.restore();
        }

        function sharpenImage(canvas, amount) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            for (let i = 0; i < data.length; i += 4) {
                if (i > canvas.width * 4 && i < data.length - canvas.width * 4) {
                    data[i] = Math.max(0, Math.min(255, data[i] + (data[i] - data[i - 4]) * amount));
                    data[i+1] = Math.max(0, Math.min(255, data[i+1] + (data[i+1] - data[i+1 - 4]) * amount));
                    data[i+2] = Math.max(0, Math.min(255, data[i+2] + (data[i+2] - data[i+2 - 4]) * amount));
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        function handleFiles(files) {
            if (files.length === 0) return;
            
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            images = [];
            originalImages = [];
            framesContainer.innerHTML = '';
            
            Array.from(files).forEach(file => {
                if (!file.type.match('image.*')) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = function() {
                        images.push(img);
                        originalImages.push({
                            src: e.target.result,
                            file: file,
                            name: file.name
                        });
                        addFrameToContainer(img);
                        updateCreateButton();
                        
                        // Show editor section when first image is loaded
                        if (images.length === 1) {
                            editorSection.style.display = 'block';
                        }
                    };
                };
                reader.readAsDataURL(file);
            });
        }

        function addFrameToContainer(img) {
            const frame = document.createElement('img');
            frame.className = 'frame';
            frame.src = img.src;
            frame.addEventListener('click', () => {
                document.querySelectorAll('.frame').forEach(f => f.style.borderColor = '#444444');
                frame.style.borderColor = 'var(--primary)';
                drawImageToCanvas(img);
                previewContainer.style.display = 'block';
            });
            framesContainer.appendChild(frame);
            
            // Select the first frame by default
            if (framesContainer.children.length === 1) {
                frame.style.borderColor = 'var(--primary)';
                drawImageToCanvas(img);
                previewContainer.style.display = 'block';
            }
        }

        function drawImageToCanvas(img) {
            const size = parseInt(sizeControl.value);
            gifCanvas.width = size;
            gifCanvas.height = size;
            
            // Apply all image effects
            const processedCanvas = applyImageEffects(img, size);
            ctx.clearRect(0, 0, gifCanvas.width, gifCanvas.height);
            
            // Always use black background
            ctx.fillStyle = '#111111';
            ctx.fillRect(0, 0, gifCanvas.width, gifCanvas.height);
            
            ctx.drawImage(processedCanvas, 0, 0);
            
            // Draw text elements
            if (textElements.length > 0) {
                textElements.forEach(text => {
                    drawTextElement(ctx, text, size);
                });
            }
            
            // Draw watermark if enabled
            if (watermarkSettings.enabled) {
                drawWatermark(ctx, size);
            }
        }

        function updateSpeedValue() {
            const speed = parseInt(speedControl.value);
            let speedDescription = "";
            
            if (speed < 200) speedDescription = " (Very Fast)";
            else if (speed < 400) speedDescription = " (Fast)";
            else if (speed < 700) speedDescription = " (Normal)";
            else if (speed < 1000) speedDescription = " (Slow)";
            else speedDescription = " (Very Slow)";
            
            speedValue.textContent = speed + "ms" + speedDescription;
            
            if (animationInterval) {
                clearInterval(animationInterval);
                startAnimation();
            }
        }

        function updateGifSpeedValue() {
            const speed = parseInt(gifSpeedControl.value);
            let speedDescription = "";
            
            if (speed < 500) speedDescription = " (Fast)";
            else if (speed < 1000) speedDescription = " (Normal)";
            else if (speed < 3000) speedDescription = " (Slow)";
            else if (speed < 8000) speedDescription = " (Very Slow)";
            else speedDescription = " (Extremely Slow)";
            
            gifSpeedValue.textContent = speed + "ms" + speedDescription;
        }

        function updateSizeValue() {
            sizeValue.textContent = sizeControl.value;
            if (images.length > 0) {
                if (animationInterval) {
                    drawImageToCanvas(images[0]);
                } else if (framesContainer.querySelector('.frame')) {
                    const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
                    if (selectedFrame) {
                        const img = new Image();
                        img.src = selectedFrame.src;
                        img.onload = () => drawImageToCanvas(img);
                    }
                }
            }
        }

        function updateCreateButton() {
            createGifBtn.disabled = images.length < 2;
        }

        function startAnimation() {
            const delay = parseInt(speedControl.value);
            let currentIndex = 0;
            
            if (images.length > 0) {
                drawImageToCanvas(images[0]);
                previewContainer.style.display = 'block';
            }
            
            animationInterval = setInterval(() => {
                currentIndex = (currentIndex + 1) % images.length;
                drawImageToCanvas(images[currentIndex]);
            }, delay);
        }

        function createGif() {
            if (images.length < 2) return;
            
            loading.style.display = 'block';
            createGifBtn.disabled = true;
            createHdImageBtn.disabled = true;
            downloadLink.style.display = 'none';
            
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            const size = parseInt(sizeControl.value);
            const gifDelay = parseInt(gifSpeedControl.value);
            const quality = parseInt(qualityControl.value);
            
            const gif = new GIF({
                workers: 4,
                quality: 21 - quality,
                width: size,
                height: size,
                workerScript: "{% static 'main/js/gif.worker.js' %}",
                repeat: 0,
                background: '#000000',
                dither: 'FloydSteinberg-serpentine',
                optimize: true,
                maxWorkers: 4
            });
            
            images.forEach(img => {
                const enhancedCanvas = enhanceImage(img, size);
                const frameCanvas = document.createElement('canvas');
                frameCanvas.width = size;
                frameCanvas.height = size;
                const frameCtx = frameCanvas.getContext('2d');
                
                frameCtx.fillStyle = '#000000';
                frameCtx.fillRect(0, 0, size, size);
                frameCtx.shadowColor = 'rgba(255,255,255,0.1)';
                frameCtx.shadowBlur = 8;
                frameCtx.shadowOffsetY = 4;
                
                frameCtx.drawImage(enhancedCanvas, 0, 0);
                frameCtx.shadowColor = 'transparent';
                
                gif.addFrame(frameCanvas, {
                    delay: Math.max(1, Math.round(gifDelay / 10)),
                    copy: true,
                    dispose: 1
                });
            });
            
            gif.on('finished', function(blob) {
                loading.style.display = 'none';
                createGifBtn.disabled = false;
                createHdImageBtn.disabled = false;
                
                if (currentDownloadUrl) {
                    URL.revokeObjectURL(currentDownloadUrl);
                }
                
                currentDownloadUrl = URL.createObjectURL(blob);
                currentOutputType = 'gif';
                
                downloadAnchor.href = currentDownloadUrl;
                downloadAnchor.download = `professional-quality-${Date.now()}.gif`;
                downloadHd.href = currentDownloadUrl;
                downloadHd.download = `professional-quality-${Date.now()}.gif`;
                downloadPrint.href = currentDownloadUrl;
                downloadPrint.download = `professional-quality-${Date.now()}.gif`;
                
                downloadLink.style.display = 'block';
                
                const previewImg = new Image();
                previewImg.src = currentDownloadUrl;
                previewImg.onload = () => {
                    drawImageToCanvas(previewImg);
                    previewContainer.style.display = 'block';
                };
            });

            gif.on('error', function(error) {
                loading.style.display = 'none';
                createGifBtn.disabled = false;
                createHdImageBtn.disabled = false;
                console.error('GIF creation error:', error);
                alert("Error creating GIF: " + error.message);
            });
            
            gif.render();
        }

        function createHdImage() {
            if (images.length === 0) return;
            
            loading.style.display = 'block';
            createGifBtn.disabled = true;
            createHdImageBtn.disabled = true;
            downloadLink.style.display = 'none';
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            const selectedIndex = selectedFrame ? Array.from(framesContainer.children).indexOf(selectedFrame) : 0;
            const img = images[selectedIndex];
            const originalImage = originalImages[selectedIndex];
            
            const size = parseInt(sizeControl.value);
            const quality = parseInt(qualityControl.value);
            
            setTimeout(() => {
                try {
                    const hdCanvas = enhanceImage(img, size, true);
                    
                    if (currentDownloadUrl) {
                        URL.revokeObjectURL(currentDownloadUrl);
                    }
                    
                    currentOutputType = 'image';
                    
                    // For non-transparent, offer both WebP and PNG
                    hdCanvas.toBlob(blob => {
                        const webPUrl = URL.createObjectURL(blob);
                        downloadHd.href = webPUrl;
                        downloadHd.download = `ultra-hd-${Date.now()}.webp`;
                        
                        hdCanvas.toBlob(blob => {
                            const pngUrl = URL.createObjectURL(blob);
                            downloadPrint.href = pngUrl;
                            downloadPrint.download = `print-quality-${Date.now()}.png`;
                            
                            // Original version
                            downloadOriginal.href = originalImage.src;
                            downloadOriginal.download = originalImage.name;
                            
                            // Set WebP as default for non-transparent
                            currentDownloadUrl = webPUrl;
                            downloadAnchor.href = webPUrl;
                            downloadAnchor.download = `ultra-hd-${Date.now()}.webp`;
                            
                            loading.style.display = 'none';
                            createGifBtn.disabled = false;
                            createHdImageBtn.disabled = false;
                            downloadLink.style.display = 'block';
                            
                            drawImageToCanvas(img);
                            previewContainer.style.display = 'block';
                        }, 'image/png', 1.0);
                    }, 'image/webp', quality / 20);
                    
                } catch (error) {
                    loading.style.display = 'none';
                    createGifBtn.disabled = false;
                    createHdImageBtn.disabled = false;
                    console.error('HD image creation error:', error);
                    alert("Error creating HD image: " + error.message);
                }
            }, 100);
        }

        function downloadHdVersion(e) {
            e.preventDefault();
            if (!currentDownloadUrl) return;
            
            if (currentOutputType === 'gif') {
                downloadAnchor.click();
                return;
            }
            
            const link = document.createElement('a');
            link.href = downloadHd.href;
            link.download = downloadHd.download;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function downloadPrintVersion(e) {
            e.preventDefault();
            if (!currentDownloadUrl) return;
            
            if (currentOutputType === 'gif') {
                downloadAnchor.click();
                return;
            }
            
            const link = document.createElement('a');
            link.href = downloadPrint.href;
            link.download = downloadPrint.download;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function downloadOriginalVersion(e) {
            e.preventDefault();
            if (!currentDownloadUrl) return;
            
            if (currentOutputType === 'gif') {
                downloadAnchor.click();
                return;
            }
            
            const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
            const selectedIndex = selectedFrame ? Array.from(framesContainer.children).indexOf(selectedFrame) : 0;
            const originalImage = originalImages[selectedIndex];
            
            const link = document.createElement('a');
            link.href = originalImage.src;
            link.download = originalImage.name;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        function resetAll() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            ctx.clearRect(0, 0, gifCanvas.width, gifCanvas.height);
            images = [];
            originalImages = [];
            framesContainer.innerHTML = '';
            previewContainer.style.display = 'none';
            downloadLink.style.display = 'none';
            fileInput.value = '';
            createGifBtn.disabled = true;
            createHdImageBtn.disabled = false;
            speedControl.value = 500;
            gifSpeedControl.value = 2000;
            updateSpeedValue();
            updateGifSpeedValue();
            sizeControl.value = 300;
            updateSizeValue();
            qualityPreset.value = 'medium';
            qualityControl.value = 10;
            updateQualityValue();
            loading.style.display = 'none';
            enhanceQuality.checked = true;
            
            // Reset editor settings
            resetAdjustments();
            resetFilter();
            currentRotation = 0;
            isFlipped = false;
            isCropping = false;
            hideAllEditorControls();
            
            // Reset text settings
            textElements = [];
            textInput.value = '';
            textFont.value = 'Arial';
            textSize.value = 24;
            textColor.value = '#ffffff';
            textBgColor.value = '#00000000';
            textOpacity.value = 100;
            updateTextPreview();
            updateTextSizeValue();
            updateTextOpacityValue();
            
            // Reset watermark settings
            watermarkSettings = {
                text: "@{{ username }}",
                size: 16,
                color: "#ffffff",
                opacity: 70,
                position: "bottom-right",
                enabled: false
            };
            watermarkText.value = "@{{ username }}";
            watermarkSize.value = 16;
            watermarkColor.value = "#ffffff";
            watermarkOpacity.value = 70;
            watermarkPosition.value = "bottom-right";
            updateWatermarkSizeValue();
            updateWatermarkOpacityValue();
            
            if (currentDownloadUrl) {
                URL.revokeObjectURL(currentDownloadUrl);
                currentDownloadUrl = null;
            }
        }
        
        /* Text Editor Functions */
        function updateTextPreview() {
            const content = textInput.value || 'Text Preview';
            const font = textFont.value;
            const size = parseInt(textSize.value);
            const color = textColor.value;
            const bgColor = textBgColor.value;
            const opacity = parseInt(textOpacity.value);
            
            textPreview.innerHTML = '';
            
            const previewText = document.createElement('span');
            previewText.textContent = content;
            previewText.style.fontFamily = font;
            previewText.style.fontSize = `${size}px`;
            previewText.style.color = color;
            previewText.style.backgroundColor = bgColor;
            previewText.style.opacity = opacity / 100;
            previewText.style.padding = '5px';
            previewText.style.borderRadius = '3px';
            
            textPreview.appendChild(previewText);
        }
        
        function updateTextSizeValue() {
            textSizeValue.textContent = textSize.value;
            updateTextPreview();
        }
        
        function updateTextOpacityValue() {
            textOpacityValue.textContent = textOpacity.value;
            updateTextPreview();
        }
        
        function setTextPosition(e) {
            textPositionBtns.forEach(btn => btn.classList.remove('active'));
            this.classList.add('active');
            currentTextPosition = this.dataset.position;
        }
        
        function addTextToImage() {
            const content = textInput.value.trim();
            if (!content) {
                alert('Please enter some text');
                return;
            }
            
            const textElement = {
                content: content,
                fontFamily: textFont.value,
                fontWeight: 'normal',
                size: parseInt(textSize.value),
                color: textColor.value,
                bgColor: textBgColor.value,
                opacity: parseInt(textOpacity.value),
                position: currentTextPosition
            };
            
            textElements.push(textElement);
            
            // Redraw canvas with the new text
            if (images.length > 0) {
                const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
                if (selectedFrame) {
                    const img = new Image();
                    img.src = selectedFrame.src;
                    img.onload = () => drawImageToCanvas(img);
                }
            }
            
            // Clear the input field but keep other settings
            textInput.value = '';
            updateTextPreview();
        }
        
        function clearAllText() {
            textElements = [];
            
            // Redraw canvas without text
            if (images.length > 0) {
                const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
                if (selectedFrame) {
                    const img = new Image();
                    img.src = selectedFrame.src;
                    img.onload = () => drawImageToCanvas(img);
                }
            }
        }
        
        /* Watermark Editor Functions */
        function updateWatermarkSettings() {
            watermarkSettings.text = watermarkText.value;
            watermarkSettings.size = parseInt(watermarkSize.value);
            watermarkSettings.color = watermarkColor.value;
            watermarkSettings.opacity = parseInt(watermarkOpacity.value);
            watermarkSettings.position = watermarkPosition.value;
        }
        
        function updateWatermarkSizeValue() {
            watermarkSizeValue.textContent = watermarkSize.value;
        }
        
        function updateWatermarkOpacityValue() {
            watermarkOpacityValue.textContent = watermarkOpacity.value;
        }
        
        function applyWatermark() {
            updateWatermarkSettings();
            watermarkSettings.enabled = true;
            
            // Redraw canvas with watermark
            if (images.length > 0) {
                const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
                if (selectedFrame) {
                    const img = new Image();
                    img.src = selectedFrame.src;
                    img.onload = () => drawImageToCanvas(img);
                }
            }
        }
        
        function removeWatermark() {
            watermarkSettings.enabled = false;
            
            // Redraw canvas without watermark
            if (images.length > 0) {
                const selectedFrame = framesContainer.querySelector('.frame[style*="border-color"]');
                if (selectedFrame) {
                    const img = new Image();
                    img.src = selectedFrame.src;
                    img.onload = () => drawImageToCanvas(img);
                }
            }
        }
    });
    </script>
</body>
</html>


